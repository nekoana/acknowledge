> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [juejin.cn](https://juejin.cn/post/7156065071175893028)

我正在参加「掘金 · 启航计划」

> 注:
> 
> *   本文读书笔记，出自《深入理解 LINUX 内核》
> *   千万不要将文章前面提到的 volatile 关键字与 Java 中的该关键字混淆

概述
==

      当使用优化的编辑器时，千万不要认为指令会严格的按照 ta 们在源码中出现的顺序执行。例如，编译器可能重新安排汇编语言指令以使寄存器以最优方式使用。此外，现代 CPU 通常并行执行若干条指令，且可能重新安排内存访问。这种重新排序可以极大地加速程序执行。

      然而处理同步场景时，必须避免指令重排序。如果放在同步原语之后的一条指令在同步原语本身之前执行，事情很快变得失控。事实上，所有同步原语起到优化和 (或) 内存屏障的作用。

优化屏障
====

      `优化屏障`(optimization barrier) 原语保证编译程序不会混淆放在原语操作之前的汇编语言指令和放在原语之后的汇编语言指令，这些汇编语言指令在 C 中都有对应的语句。在 Linux 中，优化屏障就是`barrier()宏`，ta 展开为:

```
__asm__ volatile ("" : : : "memory");
复制代码
```

      指令 asm 告诉编译程序要插入汇编语言片段 (这种情况下为空)。`volatile`关键字禁止编译器把 asm 指令与程序中其他指令重新组合。`memory`关键字强制编译器假定 RAM 中所有内存单元已经被汇编语言指令修改；因此，编译器不能使用存放在 CPU 寄存器中的内存单元的值来优化 asm 指令前的代码。注意，优化屏障并不保证不使当前 CPU 把汇编语言指令混在一起执行 -- 这是内存屏障的工作。

_笔者注:_

*   _GCC 支持嵌入汇编代码的模板，不同于其它 C 编译器支持嵌入汇编代码的方式，为了优化用户代码，GCC 设计了一种特有的嵌入方式，它规定了汇编代码嵌入的形式和嵌入汇编代码需要由哪几个部分组成_

```
__asm__ volatile(代码部分:输出部分列表: 输入部分列表:损坏部分列表);
复制代码
```

*   _前面的部分都是固定的，括号中的内容如下:_
    *   _汇编代码部分，这里是实际嵌入的汇编代码_
    *   _输出列表部分，让 GCC 能够处理 C 语言左值表达式与汇编代码的结合_
    *   _输入列表部分，也是让 GCC 能够处理 C 语言表达式、变量、常量，让它们能够输入到汇编代码中去_
    *   _损坏列表部分，告诉 GCC 汇编代码中用到了哪些寄存器，以便 GCC 在汇编代码运行前，生成保存它们的代码，并且在生成的汇编代码运行后，恢复它们 (寄存器) 的代码_
*   _括号前面部分固定内容，笔者已经见过三种形式_：

```
/* 《深入理解LINUX内核》 */
asm volatile

/* JVM源码 */
__asm__ volatile

/* 其他资料 */
__asm__ __volatile__
复制代码
```

*   _关于多种形式的问题，很多资料都解释的模棱两可，我请教了一个相关方面的大佬他的解释: 因为这些并不是 C 语言的一部分，而是编译器的一部分，GCC，MSVC 等，用了各自的语法，不过后面大家也在互相参考和兼容，有些就变成了事实标准_ ![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfd5229fffc14f95b3a780e0f0948dbd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

内存屏障
====

      `内存屏障`(memory barrier) 原语确保，在原语之后的操作开始之前，原语之前的操作已经完成。因此，内存屏障类似于防火墙，让任何汇编语言指令都不能通过。

      在 80x86 处理器中，下列种类的汇编指令是 "串行的"，因为 ta 们起到内存屏障的作用:

*   对 I/O 端口进行操作的所有指令
*   lock 前缀的所有指令
*   写控制寄存器，系统寄存器或调试寄存器的所有指令 (例如: cli、sti)
*   在 Pentium 4 微处理器中引入的汇编语言指令`lfence` `sfence` `mfence`，ta 们分别有效的实现读内存屏障、写内存屏障、读 - 写内存屏障
*   少数专门的汇编语言指令，终止中断处理程序或异常处理程序的 iret 指令就是其中的一个

_笔者注_:

*   _CLI 汇编指令全称为 Clear Interupt，该指令的作用是禁止中断发生_
*   _STI 汇编指令全称为 Set Interupt，该指令的作用是允许中断发生_
*   _该对指令的原理就是修改 eflag 寄存器的 IF 标志位状态，IF 标志、CLI 和 STI 指令对异常和 NMI 中断的产生没有影响_

      Linux 使用六个内存屏障原语。这些原语也具有优化屏障的作用，因为我们必须保证编译程序不在屏障前后移动汇编语言指令。"对内存屏障" 仅仅作用于从内存读的指令，而 "写内存屏障" 仅仅作用于写内存指令。

      内存屏障既用于多处理器系统，也用于单处理器系统。 当内存屏障应该放置仅出现于多处理器系统上的竞争条件时，就使用 smp_xxx() 原语；在单处理系统上，ta 们什么也不做。其他的内存屏障防止出现在单处理器和多处理器系统上的竞争条件。

<table><thead><tr><th>宏</th><th>说明</th></tr></thead><tbody><tr><td>mb()</td><td>适用于 MP 和 UP 的内存屏障</td></tr><tr><td>rmb()</td><td>适用于 MP 和 UP 的读内存屏障</td></tr><tr><td>wmb()</td><td>适用于 MP 和 UP 的写内存屏障</td></tr><tr><td>smp_mb()</td><td>仅适用于 MP 的内存屏障</td></tr><tr><td>smp_rmb()</td><td>仅适用于 MP 的读内存屏障</td></tr><tr><td>smp_wmb()</td><td>仅适用于 MP 的写内存屏障</td></tr></tbody></table>

架构决定实现
======

      内存屏障原语的实现依赖于系统的体系结构。在 80x86 微处理器上，如果 CPU 支持`lfence`汇编语言指令，就把 rmb() 宏展开为:

```
__asm__ volatile ("lfence");
复制代码
```

      否则就展开为:

```
__asm__ volatile ("lock;addl $0,0(%%esp)":::"memory")
复制代码
```

      asm 指令告诉编译器插入一些汇编指令并起优化屏障的作用。addl $0,0(%%esp) 汇编指令把 0 加到栈顶的内存单元，这条指令毫无意义本身没有任何价值，但是加上 lock 前缀就使得该指令成为 CPU 的一个内存屏障。

_笔者注:_

*   _32 位、64 位机器的栈顶寄存器名字稍微有所差别，分别叫 esp、rsp_
*   _查阅 Intel 官方手册得知: LOCK 前缀只能加在以下指令前面，也只能加在目标操作数是内存操作数的指令形式后面: ADD、ADC、and、BTC、BTR、BTS、CMPXCHG、CMPXCH8B、CMPXCHG16B、DEC、INC、NEG、NOT、OR、SBB、SUB、XOR、XADD 和 XCHG_
*   _addl $0,0(%%esp) 这句指令没有任何特殊之处，仅仅是因为满足了上述条件，然后执行指令本身的消耗足够小_
*   _JVM 实现内存屏障也是上述方式 (lock 前缀 + 空操作)，笔者总结原因有两个:_
    *   _并不是所有的 CPU 都支持 fence 家族汇编指令_
    *   _JVM 源码注释：总是使用 lock addl，因为 mfence 有时很昂贵_

      Inter 上的 wmb() 宏实际上更加简单，因为他直接展开为 barrier()，这是因为 Inter 处理器从不对写内存访问重排序，因此，没有必要在代码中插入一条串行化汇编指令，不过因为`barrier()`这个宏上文已经提到禁止编译器重新组合指令。

引用
==

*   《深入理解 LINUX 内核》
*   [JVM: orderAccess_linux_x86.hpp](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fopenjdk%2Fjdk%2Fblob%2Fmaster%2Fsrc%2Fhotspot%2Fos_cpu%2Flinux_x86%2ForderAccess_linux_x86.hpp "https://github.com/openjdk/jdk/blob/master/src/hotspot/os_cpu/linux_x86/orderAccess_linux_x86.hpp")
*   《操作系统实战 45 讲》